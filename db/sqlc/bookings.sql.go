// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: bookings.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createBooking = `-- name: CreateBooking :execresult
INSERT INTO bookings(id,fname,lname,job,email,phone,country,address,message,productId)
    VALUES (?,?,?,?,?,?,?,?,?,?)
`

type CreateBookingParams struct {
	ID        string
	Fname     string
	Lname     string
	Job       string
	Email     string
	Phone     string
	Country   string
	Address   string
	Message   string
	Productid uint32
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createBooking,
		arg.ID,
		arg.Fname,
		arg.Lname,
		arg.Job,
		arg.Email,
		arg.Phone,
		arg.Country,
		arg.Address,
		arg.Message,
		arg.Productid,
	)
}

const showAllBookings = `-- name: ShowAllBookings :many
select id, createdat, updatedat, deletedat, fname, lname, job, email, phone, country, address, message, productid from bookings
`

func (q *Queries) ShowAllBookings(ctx context.Context) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, showAllBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.Deletedat,
			&i.Fname,
			&i.Lname,
			&i.Job,
			&i.Email,
			&i.Phone,
			&i.Country,
			&i.Address,
			&i.Message,
			&i.Productid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
